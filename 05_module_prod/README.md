# Модуль 5 — Продакшн: карта понимания

Это как поставить камеры на кухне: видно, что готовится и где ошибка.

Здесь подробная и понятная карта модуля 5: что мы делали и зачем.

---

## 1) Зачем этот модуль

- логировать промпты и ответы  
- видеть метрики качества  
- быстро находить ошибки  
- повторять эксперименты  

---

## 2) Блок A — трассировка

### `01_tracing_langsmith.ipynb`
**Якорь:** как запись с видеокамеры, чтобы понять, что пошло не так.  

**Что делаем:**
- ставим библиотеки  
- включаем трассировку  
- настраиваем ключ  
- запускаем цепочку  

**Мини‑схема**
```
Запрос → Chain → Логи
```

**Микро‑упражнение:**  
Запусти цепочку 2 раза и сравни ответы в LangSmith.

**Почему важно:** без трассировки ты не знаешь, что именно сгенерировала модель.

---

## 3) Мини‑примеры кода (ещё подробнее)

### Пример 1: Включить трассировку
```python
os.environ["LANGCHAIN_TRACING_V2"] = "true"
# Схема: флаг → логирование
```
**Почему важно:** без флага логи не отправятся.

### Пример 2: Задать ключ LangSmith
```python
os.environ["LANGCHAIN_API_KEY"] = getpass("Введите LANGCHAIN_API_KEY: ")
# Схема: ключ → доступ к логам
```
**Почему важно:** без ключа нельзя открыть трассы.

### Пример 3: Логируем цепочку
```python
chain = prompt | llm | StrOutputParser()
result = chain.invoke({})
# Схема: промпт → модель → результат
```
**Почему важно:** любые вызовы через LangChain попадут в LangSmith.

---

## 4) Микро‑проверка (с ответом)

Вопрос: что нужно включить, чтобы трассировка заработала?  
Ответ: `LANGCHAIN_TRACING_V2 = "true"` и ключ `LANGCHAIN_API_KEY`.

---

## 5) Итог модуля (4 результата)

- включаешь трассировку  
- видишь промпты и ответы  
- находишь ошибки  
- повторяешь эксперименты  

---

Попробуй: открой `01_tracing_langsmith.ipynb` и пройди его сверху вниз.

---

## 3) Блок B — кэш и rate limit

### `02_caching_rate_limit.ipynb`
**Якорь:** как повторить заказ в кафе и получить его быстрее.  

**Что делаем:**
- включаем кэш в памяти  
- сохраняем кэш на диске  
- ограничиваем частоту запросов  
- проверяем скорость  

**Мини‑схема**
```
Запрос → Кэш → Ответ
```

**Микро‑упражнение:**  
Сделай один и тот же запрос дважды и сравни время.

**Почему важно:** меньше расходов и стабильнее работа.

---

## 4) Блок C — тесты и качество

### `03_testing_evaluation.ipynb`
**Якорь:** как контрольные вопросы после урока.  

**Что делаем:**
- пишем мини‑тесты  
- проверяем «золотой набор»  
- считаем точность  
- ловим регрессии  

**Мини‑схема**
```
Вопросы → Ответы → Оценка
```

**Микро‑упражнение:**  
Добавь 1 новый вопрос в golden set.

**Почему важно:** без тестов качество плавает.

---

## 5) Блок D — мини‑деплой

### `04_deployment_miniserver.ipynb`
**Якорь:** как открыть маленькое окошко выдачи заказов.  

**Что делаем:**
- создаём FastAPI  
- поднимаем сервер  
- делаем POST‑запрос  
- получаем ответ  

**Мини‑схема**
```
Запрос → API → Ответ
```

**Микро‑упражнение:**  
Смени вопрос и посмотри, как изменится ответ.

**Почему важно:** так цепочка превращается в сервис.

---

## 6) Блок E — устойчивость (retry/backoff)

### `05_retries_backoff.ipynb`
**Якорь:** как перезвонить клиенту, если связь сорвалась.  

**Что делаем:**
- пишем простой retry  
- добавляем экспоненциальную задержку  
- оборачиваем вызов LLM  

**Мини‑схема**
```
Ошибка → Пауза → Повтор
```

**Микро‑упражнение:**  
Сделай 5 попыток и посмотри, как растёт пауза.

**Почему важно:** временные ошибки не ломают сервис.
