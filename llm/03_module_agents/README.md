# Модуль 3 — Агенты и инструменты: карта понимания

```
┌─────────────────────────────────────────────────────────────┐
│  АГЕНТЫ как умный помощник с кнопками: сам решает,          │
│  но кнопки безопасные                                         │
├────────────┬────────────┬────────────┬──────────────────────┤
│ Якорь     │ Механика   │ Прорыв     │ Применение           │
│ 3 сек     │ 20 сек     │ ✨ 5 сек   │ 10 сек               │
│ Ножницы   │ Tools +    │ Память     │ Защита от рисков     │
│ с защитой │ валидация  │ k=3        │                      │
└────────────┴────────────┴────────────┴──────────────────────┘
```

---

## 🎯 Якорь + эмоциональный мостик

**🎯 ЯКОРЬ:** Ножницы для ребёнка — с закруглёнными концами. Инструмент есть, но он безопасный. Так же и Tools для агента: он может «нажать кнопку», но ты задаёшь границы (limit, типы).

💡 **Эмпатия:** «Звучит опасно? Сейчас станет проще, чем настроить родительский контроль.»

---

## 📖 Термины и понятия

| Термин | Что это | Метафора |
|--------|---------|----------|
| **Агент** | LLM + tools: сам выбирает, какой инструмент вызвать. | 🤖 Помощник с пультом |
| **Tool** | Функция, которую агент вызывает: поиск, API. | ✋ Кнопка на пульте |
| **args_schema** | Схема входов: `Field(ge=1, le=10)`. Защита от limit=999. | 🛡️ Рамка для ввода |
| **Function-style** | Строгий вызов по инструкции. | 📋 Чек-лист |
| **ReAct** | Думает → вызывает tool → смотрит результат → думает снова. | 🧠 Рассуждение + действие |
| **Память (k=3)** | Последние k сообщений. Экономия токенов. | 📓 Блокнот на 3 страницы |
| **max_iterations** | Лимит шагов. От «зацикливания». | ⏱️ Таймер |

---

## 📐 Радиальная карта модуля

```
                         ┌──────────────────┐
                         │   АГЕНТЫ         │ ← ЦЕНТР
                         │   (Модуль 3)     │
                         └────────┬─────────┘
              ┌───────────────────┼───────────────────┐
              ↓                   ↓                   ↓
       ┌────────────┐     ┌────────────┐     ┌────────────┐
       │ Инструменты│     │ Типы       │     │ Память +   │
       │ (Tools)   │     │ агентов    │     │ Безопасность│
       └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
             ↓                  ↓                   ↓
       • args_schema       • Function-style  • Окно k=3
       • Валидация         • ReAct           • Правила
       • limit (ge, le)
```

---

## 🔷 Прогрессивная схема (3 фазы)

#### Фаза 1: Создание инструмента
```
┌──────────────┐
│  Вход        │  query, limit
└──────┬───────┘
       ↓
┌──────────────┐
│  args_schema │  ← Pydantic: ge=1, le=10
│  (проверка)  │
└──────┬───────┘
       ↓
┌──────────────┐
│  Действие    │  поиск, вызов API
└──────────────┘
```

#### Фаза 2: Агент выбирает инструмент
```
┌──────────────┐
│   Запрос     │
│   пользователя│
└──────┬───────┘
       ↓
┌──────────────┐
│   Агент      │  Function or ReAct
└──────┬───────┘
       ├──────────────┬──────────────┐
       ↓              ↓              ↓
  ┌─────────┐   ┌─────────┐   ┌─────────┐
  │ Tool 1  │   │ Tool 2  │   │ Tool 3  │
  └─────────┘   └─────────┘   └─────────┘
```

#### Фаза 3: Прорыв ← ✨ ВОТ ЗДЕСЬ МАГИЯ!
```
┌──────────────┐
│  Память      │  k=3 (последние 3 сообщения)
└──────┬───────┘
       ↓
✨ Агент «помнит» контекст БЕЗ переполнения лимитов
   И получает только ВАЛИДНЫЕ входы (args_schema)
```

---

## 📊 Таблица контрастов

| Что думают ❌ | Что на самом деле ✅ | Визуальная метафора |
|---------------|---------------------|----------------------|
| «Агент может сделать что угодно» | Tools = ограниченный набор «кнопок» | `Кнопки пульта = только заданные действия` |
| «Без args_schema тоже сработает» | Плохие входы → ошибки или атаки | `Валидатор = рамка для ввода (1–10)` |
| «Function и ReAct — одно» | Function = строгий вызов, ReAct = рассуждение + действие | `Инструкция vs свободное мышление` |
| «Память = всё подряд» | Окно k=3 → экономия токенов | `Блокнот с последними 3 записями` |

---

## 💻 Мини-код с комментариями-стрелками

```python
# ← 1. args_schema = «рамка» для ввода (защита)
class SearchArgs(BaseModel):
    query: str
    limit: int = Field(ge=1, le=10)
#        ↑
#        └─── ✨ ВОТ ЗДЕСЬ МАГИЯ: агент не получит limit=999

# ← 2. Tool = кнопка с валидацией
class ProductSearchTool(BaseTool):
    name = "product_search"
    args_schema = SearchArgs  # ← 3. Схема привязана к инструменту

# ← 4. Память: последние k сообщений
memory = ConversationBufferWindowMemory(k=3)
```

---

## ✅ Чек-лист самопроверки

```
✅ Проверь себя за 15 секунд:
▫️ Могу объяснить Tools через метафору «ножницы с защитой»
▫️ Вижу разницу между Function-style и ReAct
▫️ Знаю, зачем args_schema (защита от плохих входов)
▫️ Могу ограничить память окном k=3
▫️ Понимаю, зачем валидация (limit, типы)

→ Если 4+ галочки — уверенно владеешь основой.
```

---

## 🔍 Микро-проверка

**Вопрос:** Зачем args_schema, если агент «умный»?  
**Ответ:** Модель может вызвать tool с limit=999999 — перегрузка API. Схема ограничивает: ge=1, le=10. Рамка безопасности.

**Вопрос:** Function vs ReAct — в чём разница?  
**Ответ:** Function = строгая инструкция «вызови X». ReAct = модель сама рассуждает, когда и что вызывать. Инструкция vs свободное мышление.

---

## ⚠️ Частые ошибки

| Ошибка | Решение |
|--------|---------|
| Агент передаёт limit=999 в tool | `Field(ge=1, le=10)` в args_schema — без схемы валидации нет |
| ReAct «зацикливается» на одном tool | Ограничь max_iterations, добавь таймаут |

---

## ➡️ Что дальше

- **Модуль 4** — RAG: retrieval + generation (агент может искать в базе).
- **ДЗ 8** — Tools + fine-tuning: модель с «руками».

**≈40 мин** — блокноты | **≈1.5 ч** — свой tool с валидацией

---

## 📁 Блокноты модуля

| Файл | Якорь | Что делаем |
|------|-------|-------------|
| `01_custom_tools.ipynb` | Ножницы с защитой | Вход → Проверка → Действие |
| `02_agent_types.ipynb` | Робот с инструкцией vs думающий | Function vs ReAct |
| `03_agent_memory_security.ipynb` | Блокнот на 3 мысли | Память + правила |

---

**Попробуй:** открой `01_custom_tools.ipynb` и пройди его сверху вниз.
