# Модуль 3 — Агенты и инструменты: карта понимания

Это как умный помощник с кнопками: он сам решает, но кнопки безопасные.

Здесь подробная и понятная карта модуля 3: что мы делали и зачем.

---

## 1) Зачем этот модуль

- делать безопасные инструменты  
- выбирать тип агента  
- хранить память  
- защищать от рисков  

---

## 2) Блок A — инструменты

### `01_custom_tools.ipynb`
**Якорь:** как дать ребёнку ножницы, но с защитой.  

**Что делаем:**
- описываем входы  
- валидируем типы  
- ограничиваем диапазоны  
- пишем безопасную логику  

**Мини‑схема**
```
Вход → Проверка → Действие
```

**Микро‑упражнение:**  
Добавь поле `limit` и запрети значения > 10.

**Почему важно:** инструмент без валидации = риск и хаос.

---

## 3) Блок B — типы агентов

### `02_agent_types.ipynb`
**Якорь:** как робот с инструкцией vs робот, который думает сам.  

**Что делаем:**
- запускаем Function‑style  
- запускаем ReAct  
- сравниваем точность  
- смотрим, кто стабильнее  

**Мини‑схема**
```
Запрос → Агент → Инструмент
```

**Микро‑упражнение:**  
Пусть оба агента решат один и тот же запрос.

**Почему важно:** разные задачи требуют разного уровня контроля.

---

## 4) Блок C — память и безопасность

### `03_agent_memory_security.ipynb`
**Якорь:** как блокнот, который хранит последние 3 мысли.  

**Что делаем:**
- включаем память  
- ограничиваем окно  
- проверяем хранение  
- добавляем правила безопасности  

**Мини‑схема**
```
Диалог → Память → Ответ
```

**Микро‑упражнение:**  
Сделай 4 сообщения и проверь, что первое забыто.

**Почему важно:** бесконечная память быстро ломает лимиты.

---

## 5) Мини‑примеры кода (ещё подробнее)

### Пример 1: Инструмент с Pydantic‑валидацией
```python
class SearchArgs(BaseModel):
    query: str
    limit: int = Field(ge=1, le=10)
# Схема: вход → проверка
```
**Почему важно:** валидатор защищает от неправильных входов.

### Пример 2: Custom Tool
```python
class ProductSearchTool(BaseTool):
    name = "product_search"
    args_schema = SearchArgs
# Схема: инструмент → безопасный вызов
```
**Почему важно:** агент получает «кнопку», а не доступ к БД.

### Пример 3: Function‑style агент
```python
agent = create_openai_functions_agent(llm, tools, prompt)
# Схема: строгий вызов → результат
```
**Почему важно:** предсказуемость и контроль.

### Пример 4: ReAct агент
```python
agent = create_react_agent(llm, tools, prompt)
# Схема: рассуждение → действие
```
**Почему важно:** гибкость в сложных задачах.

### Пример 5: Память окна
```python
memory = ConversationBufferWindowMemory(k=3)
# Схема: последние 3 сообщения
```
**Почему важно:** экономит токены и не переполняет контекст.

---

## 6) Микро‑проверка (с ответом)

Вопрос: зачем `args_schema`?  
Ответ: чтобы агент не получил «плохие» входы.

---

## 7) Итог модуля (4 результата)

- создаёшь безопасные инструменты  
- выбираешь тип агента  
- управляешь памятью  
- защищаешь систему  

---

Попробуй: открой `01_custom_tools.ipynb` и пройди его сверху вниз.
