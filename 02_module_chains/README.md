# Модуль 2 — Chains: подробный разбор

Этот файл — подробная теоретическая и практическая карта модуля 2.  
Он объясняет **зачем** нужен каждый блокнот, **как** работает ключевая техника и **как применять** её в реальных задачах.

---

## 1) `01_sequential_chain.ipynb`

### Теория
**Цепочки (Chains)** — это последовательное выполнение нескольких шагов, где результат одного шага становится входом для следующего.  
Идея: превратить «один запрос» в понятный, управляемый **пайплайн**.

**LCEL** (LangChain Expression Language) позволяет собирать цепочки через `|`, как конвейер.

**Исторически:**  
Пайплайны появились как ответ на ограничение «одного промпта».  
Сложные задачи стали решать через этапы: очистка → преобразование → анализ.

### Практика в блокноте
Вы строите ETL‑пайплайн:
1) **Очистка** (удаление шума)  
2) **Суммаризация**  
3) **Классификация** (тег)

**Ключевые параметры:**
- отдельный промпт на каждый шаг;
- низкая `temperature` для предсказуемости;
- логирование промежуточных результатов.

### Практические рекомендации
- Каждый шаг = отдельный вызов модели, это влияет на стоимость.  
- Для экономии используйте более дешевые модели на ранних шагах.  
- Четко фиксируйте формат результата каждого шага.

---

## 2) `02_router_chain.ipynb`

### Теория
**RouterChain** — маршрутизация запросов в разные цепочки.  
Смысл: разные типы запросов требуют разных промптов, моделей и логики.

**Исторически:**  
Роутеры стали важны, когда ассистенты начали обслуживать несколько доменов: поддержка, продажи, аналитика.

### Практика в блокноте
Вы строите роутер, который направляет запросы:
- в поддержку (ошибки, доставка, возврат);  
- в продажи (цены, тарифы, скидки);  
- fallback‑цепочка, если тема неясна.

**Ключевые параметры:**
- простые правила (ключевые слова)  
- fallback на случай неоднозначности

### Практические рекомендации
- Для продакшена лучше использовать LLM‑классификатор, когда ключевых слов мало.  
- Логируйте маршрутизацию, чтобы улучшать правила.  
- Делайте отдельный fallback‑путь.

---

## 3) `03_fallbacks_streaming.ipynb`

### Теория
**Fallbacks** — механизм отказоустойчивости: если основная модель недоступна, цепочка переключается на запасную.  
**Streaming** — потоковая выдача ответа в реальном времени.

**Исторически:**  
Fallbacks — стандарт продакшена: пользователю важнее получить ответ, чем «правильную» модель.  
Streaming стал важен для UX, когда чат‑интерфейсы начали имитировать «живой» ответ.

### Практика в блокноте
1) Основная модель + fallback‑модель.  
2) Потоковый вывод токенов через `stream()`.

### Практические рекомендации
- Делайте fallback на более дешевую модель.  
- Логируйте случаи fallback — это сигнал проблем качества/доступности.  
- Streaming полезен для UI, но требует обработки полного ответа, если нужна структура.

---

## Как использовать модуль 2

1. Начните с `01_sequential_chain.ipynb` — освоите цепочки.  
2. Перейдите к `02_router_chain.ipynb` — научитесь маршрутизации.  
3. Завершите `03_fallbacks_streaming.ipynb` — добавите надежность и UX.

---

## Итог модуля 2

К концу модуля вы:
- строите последовательные пайплайны;
- умеете маршрутизировать запросы;
- добавляете отказоустойчивость и потоковый вывод.
